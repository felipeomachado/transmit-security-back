/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (6.2.1).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package global.vigil.transmitsecurityback.client.endpoint;

import global.vigil.transmitsecurityback.client.dto.login.*;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@Validated
@Tag(name = "login", description = "Login Endpoints")
public interface LoginClientEndpoint {

    /**
     * POST /v1/auth/password/login : Login with password
     * Authenticate a user with a password
     *
     * @param apiPasswordLoginInput  (required)
     * @return  (status code 200)
     *         or When the  username/email and password don&#39;t match or don&#39;t exist (status code 401)
     *         or When the user has to change the password (status code 403)
     */
    @Operation(
        operationId = "login",
        summary = "Login with password",
        responses = {
            @ApiResponse(responseCode = "200", description = "", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ApiOkResponseLogin.class))
            }),
            @ApiResponse(responseCode = "401", description = "When the  username/email and password don't match or don't exist"),
            @ApiResponse(responseCode = "403", description = "When the user has to change the password", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ApiResetPasswordRequiredErrorResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/v1/auth/password/login",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    ResponseEntity<ApiOkResponseLogin> login(
        @Parameter(name = "ApiPasswordLoginInput", description = "", required = true) @Valid @RequestBody ApiPasswordLoginInput apiPasswordLoginInput
    );


    /**
     * POST /v1/auth/logout : Logout
     * Logout the user from a specific session. The user and session are derived from the access token used to authorize the request (which was issued based on the authentication that created the session)
     *
     * @return Sessions deleted Successfully (status code 200)
     *         or  (status code 400)
     *         or  (status code 401)
     */
    @Operation(
        operationId = "logout",
        summary = "Logout",
        responses = {
            @ApiResponse(responseCode = "200", description = "Sessions deleted Successfully", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ApiLogoutResponse.class))
            }),
            @ApiResponse(responseCode = "400", description = "", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = Object.class))
            }),
            @ApiResponse(responseCode = "401", description = "", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = InvalidTokenHttpError.class))
            })
        },
        security = {
            @SecurityRequirement(name = "bearer")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/v1/auth/logout",
        produces = { "application/json" }
    )
    ResponseEntity<ApiLogoutResponse> logout(
        
    );


    /**
     * POST /v1/auth/password/register : Register password
     * Creates a new user with a username and temporary password, which the user needs to reset immediately following this request.
     *
     * @param apiRegisterPasswordInput  (required)
     * @return  (status code 200)
     *         or  (status code 403)
     */
    @Operation(
        operationId = "registerPassword",
        summary = "Register password",
        responses = {
            @ApiResponse(responseCode = "200", description = "", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ApiRegisterPasswordResponse.class))
            }),
            @ApiResponse(responseCode = "403", description = "", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ForbiddenHttpError.class))
            })
        },
        security = {
            @SecurityRequirement(name = "bearer")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/v1/auth/password/register",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    ResponseEntity<ApiRegisterPasswordResponse> registerPassword(
        @Parameter(name = "ApiRegisterPasswordInput", description = "", required = true) @Valid @RequestBody ApiRegisterPasswordInput apiRegisterPasswordInput
    );


    /**
     * POST /v1/auth/password/reset : Reset password
     * Resets a user&#39;s password
     *
     * @param apiResetPasswordInput  (required)
     * @return  (status code 200)
     *         or When the new password doesn&#39;t meet the password complexity requirements (status code 400)
     *         or  (status code 403)
     */
    @Operation(
        operationId = "resetPassword",
        summary = "Reset password",
        responses = {
            @ApiResponse(responseCode = "200", description = "", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ApiResetPasswordResponse.class))
            }),
            @ApiResponse(responseCode = "400", description = "When the new password doesn't meet the password complexity requirements", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = BadRequestHttpError.class))
            }),
            @ApiResponse(responseCode = "403", description = "", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ForbiddenHttpError.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/v1/auth/password/reset",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    ResponseEntity<ApiResetPasswordResponse> resetPassword(
        @Parameter(name = "ApiResetPasswordInput", description = "", required = true) @Valid @RequestBody ApiResetPasswordInput apiResetPasswordInput
    );


    /**
     * POST /v1/auth/password/reset/email/link : Start reset by email link
     * Starts a password reset flow by sending an email magic link. Once clicked, the User Agent will be redirected to the URI specified in this request. This URI will include a passwordCode required to reset the password.
     *
     * @param apiSendResetPasswordEmailLinkInput  (required)
     * @return  (status code 200)
     *         or When the email of the user is not verified (status code 403)
     *         or When there is no user with the requested email as a primary email in the tenant (status code 404)
     */
    @Operation(
        operationId = "sendForgotPasswordEmail",
        summary = "Start reset by email link",
        responses = {
            @ApiResponse(responseCode = "200", description = "", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ApiSendResetPasswordEmailResponse.class))
            }),
            @ApiResponse(responseCode = "403", description = "When the email of the user is not verified", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ForbiddenHttpError.class))
            }),
            @ApiResponse(responseCode = "404", description = "When there is no user with the requested email as a primary email in the tenant", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = NotFoundHttpError.class))
            })
        },
        security = {
            @SecurityRequirement(name = "bearer")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/v1/auth/password/reset/email/link",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    ResponseEntity<ApiSendResetPasswordEmailResponse> sendForgotPasswordEmail(
        @Parameter(name = "ApiSendResetPasswordEmailLinkInput", description = "", required = true) @Valid @RequestBody ApiSendResetPasswordEmailLinkInput apiSendResetPasswordEmailLinkInput
    );


    /**
     * POST /v1/auth/password/reset/sms/otp : Start reset by SMS OTP
     * Starts a password reset flow by sending an SMS OTP
     *
     * @param apiSendResetPasswordSmsOtpInput  (required)
     * @return  (status code 200)
     *         or When the phone number of the user is not verified, a forbidden error will be returned (status code 403)
     *         or When there is no user with the requested phone number as primary phone number in the tenant (status code 404)
     */
    @Operation(
        operationId = "sendResetPasswordSMSOTP",
        summary = "Start reset by SMS OTP",
        responses = {
            @ApiResponse(responseCode = "200", description = "", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ApiSendResetPasswordSmsOtpResponse.class))
            }),
            @ApiResponse(responseCode = "403", description = "When the phone number of the user is not verified, a forbidden error will be returned", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ForbiddenHttpError.class))
            }),
            @ApiResponse(responseCode = "404", description = "When there is no user with the requested phone number as primary phone number in the tenant", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = NotFoundHttpError.class))
            })
        },
        security = {
            @SecurityRequirement(name = "bearer")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/v1/auth/password/reset/sms/otp",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    ResponseEntity<ApiSendResetPasswordSmsOtpResponse> sendResetPasswordSMSOTP(
        @Parameter(name = "ApiSendResetPasswordSmsOtpInput", description = "", required = true) @Valid @RequestBody ApiSendResetPasswordSmsOtpInput apiSendResetPasswordSmsOtpInput
    );


    /**
     * POST /v1/token : Exchange code for token
     * Retrieve ID and access tokens. This API is used to retrieve ID and access tokens using the code that was returned in the redirect URI as a query parameter (for example, when the user clicks a magic link). It may also create a new user if create_new_user was set to true in the send request and no user exists for the email address or phone number (depending on the flow).
     *
     * @param apiTokenExchangeRequestInput  (required)
     * @return  (status code 200)
     *         or  (status code 400)
     */
    @Operation(
        operationId = "tokenExchange",
        summary = "Exchange code for token",
        responses = {
            @ApiResponse(responseCode = "200", description = "", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ApiTokenExchangeResponse.class))
            }),
            @ApiResponse(responseCode = "400", description = "", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = BadRequestHttpError.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/v1/token",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    ResponseEntity<ApiTokenExchangeResponse> tokenExchange(
        @Parameter(name = "ApiTokenExchangeRequestInput", description = "", required = true) @Valid @RequestBody ApiTokenExchangeRequestInput apiTokenExchangeRequestInput
    );


    /**
     * POST /v1/auth/password/reset/password/validate : Start reset by password
     * Validates the current password and returns a reset token, which enables changing the user&#x60;s password
     *
     * @param apiResetPasswordByOldPasswordInput  (required)
     * @return  (status code 200)
     *         or When the provided username, password or client_id are incorrect (status code 403)
     */
    @Operation(
        operationId = "validateOldPasswordSMSOTP",
        summary = "Start reset by password",
        responses = {
            @ApiResponse(responseCode = "200", description = "", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ApiValidateResetPasswordResponse.class))
            }),
            @ApiResponse(responseCode = "403", description = "When the provided username, password or client_id are incorrect", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ForbiddenHttpError.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/v1/auth/password/reset/password/validate",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    ResponseEntity<ApiValidateResetPasswordResponse> validateOldPasswordSMSOTP(
        @Parameter(name = "ApiResetPasswordByOldPasswordInput", description = "", required = true) @Valid @RequestBody ApiResetPasswordByOldPasswordInput apiResetPasswordByOldPasswordInput
    );


    /**
     * POST /v1/auth/password/reset/sms/otp/validate : Validate reset OTP
     * Validate a reset password OTP
     *
     * @param apiVerifyResetSmsOtpInput  (required)
     * @return  (status code 200)
     *         or When the provided OTP is expired or invalid (status code 403)
     *         or When the requested user does not exist (status code 404)
     */
    @Operation(
        operationId = "validateResetPasswordSMSOTP",
        summary = "Validate reset OTP",
        responses = {
            @ApiResponse(responseCode = "200", description = "", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ApiValidateResetPasswordResponse.class))
            }),
            @ApiResponse(responseCode = "403", description = "When the provided OTP is expired or invalid", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ForbiddenHttpError.class))
            }),
            @ApiResponse(responseCode = "404", description = "When the requested user does not exist", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = NotFoundHttpError.class))
            })
        },
        security = {
            @SecurityRequirement(name = "bearer")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/v1/auth/password/reset/sms/otp/validate",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    ResponseEntity<ApiValidateResetPasswordResponse> validateResetPasswordSMSOTP(
        @Parameter(name = "ApiVerifyResetSmsOtpInput", description = "", required = true) @Valid @RequestBody ApiVerifyResetSmsOtpInput apiVerifyResetSmsOtpInput
    );

}
